name: Mayor West Orchestrator

on:
  workflow_dispatch:
  pull_request:
    types: [closed]
    paths: []
  schedule:
    - cron: '*/15 * * * *'

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Find Next Unassigned mayor-task
        id: find_task
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'mayor-task',
              state: 'open',
              assignee: 'none',
              sort: 'created',
              direction: 'asc',
              per_page: 1
            });
            
            if (issues.length === 0) {
              console.log('No unassigned mayor-tasks found');
              return { found: false };
            }
            
            const task = issues[0];
            console.log(\`Found task: #\${task.number} - \${task.title}\`);
            
            core.setOutput('task_number', task.number);
            core.setOutput('found', 'true');

      - name: Assign Copilot to Issue
        if: steps.find_task.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_AW_AGENT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const taskNumber = ${{ steps.find_task.outputs.task_number }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Step 1: Find Copilot agent ID using suggestedActors query
            console.log('Looking for copilot coding agent...');
            const findAgentQuery = \`
              query($owner: String!, $repo: String!) {
                repository(owner: $owner, name: $repo) {
                  suggestedActors(first: 100, capabilities: CAN_BE_ASSIGNED) {
                    nodes {
                      ... on Bot {
                        id
                        login
                        __typename
                      }
                    }
                  }
                }
              }
            \`;
            
            const agentResponse = await github.graphql(findAgentQuery, { owner, repo });
            const actors = agentResponse.repository.suggestedActors.nodes;
            const copilotAgent = actors.find(actor => actor.login === 'copilot-swe-agent');
            
            if (!copilotAgent) {
              console.log('Available actors:', actors.map(a => a.login).join(', '));
              throw new Error('Copilot coding agent (copilot-swe-agent) is not available for this repository');
            }
            
            console.log(\`Found copilot agent with ID: \${copilotAgent.id}\`);
            
            // Step 2: Get issue ID and current assignees
            const issueQuery = \`
              query($owner: String!, $repo: String!, $issueNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $issueNumber) {
                    id
                    assignees(first: 100) {
                      nodes { id }
                    }
                  }
                }
              }
            \`;
            
            const issueResponse = await github.graphql(issueQuery, { 
              owner, 
              repo, 
              issueNumber: taskNumber 
            });
            
            const issueId = issueResponse.repository.issue.id;
            const currentAssignees = issueResponse.repository.issue.assignees.nodes.map(a => a.id);
            
            // Step 3: Assign Copilot using replaceActorsForAssignable mutation
            const assignMutation = \`
              mutation($assignableId: ID!, $actorIds: [ID!]!) {
                replaceActorsForAssignable(input: {
                  assignableId: $assignableId,
                  actorIds: $actorIds
                }) {
                  assignable {
                    ... on Issue {
                      id
                      number
                      assignees(first: 10) {
                        nodes { login }
                      }
                    }
                  }
                }
              }
            \`;
            
            const newAssignees = [...currentAssignees, copilotAgent.id];
            const assignResponse = await github.graphql(assignMutation, {
              assignableId: issueId,
              actorIds: newAssignees
            });
            
            const assignedLogins = assignResponse.replaceActorsForAssignable.assignable.assignees.nodes.map(a => a.login);
            console.log(\`‚úÖ Assigned to issue #\${taskNumber}: \${assignedLogins.join(', ')}\`);

  merge-copilot-prs:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Read Mayor West Config
        id: config
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = '.github/mayor-west.yml';
            
            // Default config if file doesn't exist
            let config = {
              enabled: true,
              protected_paths: [
                '.github/workflows/**',
                '.github/mayor-west.yml',
                'package.json',
                'package-lock.json'
              ],
              settings: {
                merge_method: 'squash',
                audit_comments: true
              }
            };
            
            try {
              if (fs.existsSync(path)) {
                const content = fs.readFileSync(path, 'utf8');
                // Simple YAML parsing for key fields
                const enabledMatch = content.match(/^enabled:\s*(true|false)/m);
                if (enabledMatch) {
                  config.enabled = enabledMatch[1] === 'true';
                }
                
                // Extract protected paths
                const pathsMatch = content.match(/protected_paths:\s*\n([\s\S]*?)(?=\n\w|$)/);
                if (pathsMatch) {
                  const pathLines = pathsMatch[1].match(/^\s*-\s*"([^"]+)"/gm) || [];
                  config.protected_paths = pathLines.map(line => {
                    const match = line.match(/"([^"]+)"/);
                    return match ? match[1] : null;
                  }).filter(Boolean);
                }
              }
            } catch (e) {
              console.log('Using default config:', e.message);
            }
            
            console.log('Config:', JSON.stringify(config, null, 2));
            core.setOutput('enabled', config.enabled);
            core.setOutput('protected_paths', JSON.stringify(config.protected_paths));
            return config;

      - name: Find and Merge Copilot PRs
        if: steps.config.outputs.enabled == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_AW_AGENT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const protectedPaths = JSON.parse('${{ steps.config.outputs.protected_paths }}');
            
            // Helper function to check if a path matches any protected pattern
            function isProtectedPath(filePath, patterns) {
              for (const pattern of patterns) {
                // Convert glob to regex
                const regexPattern = pattern
                  .replace(/\*\*/g, '<<<DOUBLESTAR>>>')
                  .replace(/\*/g, '[^/]*')
                  .replace(/<<<DOUBLESTAR>>>/g, '.*')
                  .replace(/\./g, '\\.')
                  .replace(/\?/g, '.');
                
                const regex = new RegExp(\`^\${regexPattern}$\`);
                if (regex.test(filePath)) {
                  return true;
                }
              }
              return false;
            }
            
            // Find open PRs from Copilot
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 10
            });
            
            const copilotPRs = prs.filter(pr => 
              pr.user.login === 'copilot' || 
              pr.user.login === 'copilot[bot]' ||
              pr.user.login === 'copilot-swe-agent[bot]'
            );
            
            console.log(\`Found \${copilotPRs.length} Copilot PRs to process\`);
            
            for (const pr of copilotPRs) {
              console.log(\`\nProcessing PR #\${pr.number}: \${pr.title}\`);
              
              // Check if PR is draft
              if (pr.draft) {
                console.log('  ‚è∏Ô∏è  Skipping draft PR');
                continue;
              }
              
              // Get files changed in this PR
              const { data: files } = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: pr.number
              });
              
              const changedFiles = files.map(f => f.filename);
              console.log(\`  Changed files: \${changedFiles.join(', ')}\`);
              
              // Check for protected paths
              const protectedFiles = changedFiles.filter(f => isProtectedPath(f, protectedPaths));
              
              if (protectedFiles.length > 0) {
                console.log(\`  üõ°Ô∏è  PR touches protected paths: \${protectedFiles.join(', ')}\`);
                console.log('  ‚è∏Ô∏è  Skipping auto-merge - requires human review');
                
                // Add comment explaining why it wasn't merged
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: \`## üõ°Ô∏è Mayor West Security Review Required
                  
This PR touches protected paths and requires human review before merge:

\${protectedFiles.map(f => \`- \\\`\${f}\\\`\`).join('\n')}

**Protected paths are defined in** \\\`.github/mayor-west.yml\\\`

Once reviewed, you can merge this PR manually.\`
                });
                continue;
              }
              
              // Check if mergeable
              const { data: prDetails } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number
              });
              
              if (prDetails.mergeable_state !== 'clean') {
                console.log(\`  ‚ö†Ô∏è  PR is not in clean mergeable state: \${prDetails.mergeable_state}\`);
                continue;
              }
              
              // Merge the PR
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: \`[MAYOR] \${pr.title} (#\${pr.number})\`
                });
                
                console.log(\`  ‚úÖ Merged PR #\${pr.number}\`);
                
                // Add audit comment
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: \`## ü§† Mayor West Auto-Merged
                  
**Merged at:** \${new Date().toISOString()}
**Changed files:** \${changedFiles.length}
**Method:** squash

---
*Autonomous merge by Mayor West Orchestrator*\`
                });
                
              } catch (mergeError) {
                console.log(\`  ‚ùå Failed to merge: \${mergeError.message}\`);
              }
            }
