name: Mayor West Orchestrator
# Autonomous task assignment and PR merge workflow
# IMPORTANT: Uses pull_request_target to run in base repo context
# This avoids "first-time contributor" approval requirements for Copilot PRs

on:
  workflow_dispatch:
  issues:
    types: [opened, labeled]
  pull_request_target:
    types: [opened, synchronize, closed]
  # Run periodically to catch pending approvals
  schedule:
    - cron: '*/5 * * * *'

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  # Job 0: Auto-approve pending workflow runs from Copilot
  approve-copilot-runs:
    runs-on: ubuntu-latest
    steps:
      - name: Approve Pending Copilot Workflow Runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_AW_AGENT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Find runs that need approval (action_required status)
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              status: 'action_required',
              per_page: 20
            });
            
            if (runs.workflow_runs.length === 0) {
              console.log('No workflow runs awaiting approval');
              return;
            }
            
            console.log(`Found ${runs.workflow_runs.length} runs awaiting approval`);
            
            for (const run of runs.workflow_runs) {
              const actor = run.actor?.login?.toLowerCase() || '';
              const triggeringActor = run.triggering_actor?.login?.toLowerCase() || '';
              
              const isCopilot = actor.includes('copilot') || triggeringActor.includes('copilot');
              
              if (!isCopilot) {
                console.log(`Skipping run ${run.id} - not from Copilot (actor: ${actor})`);
                continue;
              }
              
              console.log(`Approving run ${run.id} (${run.name}) from ${actor}`);
              
              try {
                // Approve the pending deployment
                const { data: pendingDeployments } = await github.rest.actions.getPendingDeploymentsForRun({
                  owner,
                  repo,
                  run_id: run.id
                });
                
                if (pendingDeployments.length > 0) {
                  const envIds = pendingDeployments.map(d => d.environment.id);
                  await github.rest.actions.reviewPendingDeploymentsForRun({
                    owner,
                    repo,
                    run_id: run.id,
                    environment_ids: envIds,
                    state: 'approved',
                    comment: 'Auto-approved by Mayor West Orchestrator'
                  });
                  console.log(`  Approved deployments for run ${run.id}`);
                } else {
                  // No pending deployments, try re-running the workflow
                  console.log(`  No pending deployments, attempting rerun...`);
                  try {
                    await github.rest.actions.reRunWorkflow({
                      owner,
                      repo,
                      run_id: run.id
                    });
                    console.log(`  Re-triggered run ${run.id}`);
                  } catch (e) {
                    console.log(`  Could not rerun: ${e.message}`);
                  }
                }
              } catch (error) {
                console.log(`  Error approving run ${run.id}: ${error.message}`);
              }
            }

  orchestrate:
    runs-on: ubuntu-latest
    needs: [approve-copilot-runs]
    if: always()
    
    steps:
      - name: Find Next Unassigned mayor-task
        id: find_task
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // RULE: Only 1 PR at a time - check if Copilot already has an open PR
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 50
            });
            
            const openCopilotPR = prs.find(pr => {
              const login = pr.user.login.toLowerCase();
              return login === 'copilot-swe-agent' || login.includes('copilot');
            });
            
            if (openCopilotPR) {
              console.log(`Copilot already has open PR #${openCopilotPR.number}: ${openCopilotPR.title}`);
              console.log('Waiting for it to be merged before assigning next task.');
              return { found: false };
            }
            
            // Find oldest unassigned mayor-task
            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              labels: 'mayor-task',
              state: 'open',
              assignee: 'none',
              sort: 'created',
              direction: 'asc',
              per_page: 1
            });
            
            if (issues.length === 0) {
              console.log('No unassigned mayor-tasks found');
              return { found: false };
            }
            
            const task = issues[0];
            console.log(`Found task: #${task.number} - ${task.title}`);
            
            core.setOutput('task_number', task.number);
            core.setOutput('found', 'true');

      - name: Assign Copilot to Issue
        if: steps.find_task.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_AW_AGENT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const taskNumber = ${{ steps.find_task.outputs.task_number }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Step 1: Find Copilot agent ID using suggestedActors query
            console.log('Looking for copilot coding agent...');
            const findAgentQuery = `
              query($owner: String!, $repo: String!) {
                repository(owner: $owner, name: $repo) {
                  suggestedActors(first: 100, capabilities: CAN_BE_ASSIGNED) {
                    nodes {
                      ... on Bot {
                        id
                        login
                        __typename
                      }
                    }
                  }
                }
              }
            `;
            
            const agentResponse = await github.graphql(findAgentQuery, { owner, repo });
            const actors = agentResponse.repository.suggestedActors.nodes;
            const copilotAgent = actors.find(actor => actor.login === 'copilot-swe-agent');
            
            if (!copilotAgent) {
              console.log('Available actors:', actors.map(a => a.login).join(', '));
              throw new Error('Copilot coding agent (copilot-swe-agent) not available');
            }
            
            console.log(`Found copilot agent with ID: ${copilotAgent.id}`);
            
            // Step 2: Get issue ID and current assignees
            const issueQuery = `
              query($owner: String!, $repo: String!, $issueNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $issueNumber) {
                    id
                    assignees(first: 100) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            
            const issueResponse = await github.graphql(issueQuery, { owner, repo, issueNumber: taskNumber });
            const issueId = issueResponse.repository.issue.id;
            const currentAssignees = issueResponse.repository.issue.assignees.nodes.map(a => a.id);
            
            // Step 3: Assign Copilot using replaceActorsForAssignable mutation
            const actorIds = [copilotAgent.id, ...currentAssignees.filter(id => id !== copilotAgent.id)];
            
            const assignMutation = `
              mutation($assignableId: ID!, $actorIds: [ID!]!) {
                replaceActorsForAssignable(input: {
                  assignableId: $assignableId,
                  actorIds: $actorIds
                }) {
                  __typename
                }
              }
            `;
            
            await github.graphql(assignMutation, { assignableId: issueId, actorIds });
            console.log(`Successfully assigned Copilot to issue #${taskNumber}`);
            
            // Step 4: Add comment with instructions
            const commentBody = [
              '**@copilot-swe-agent** assigned to this task.',
              '',
              '**Before starting, read:**',
              '- `.github/copilot/instructions.md` - Your operating protocol',
              '- `.github/copilot-instructions.md` - Project rules',
              '',
              '**Key requirements:**',
              '1. Run `npm test` before committing',
              '2. Use commit format: `[MAYOR] <description>`',
              `3. Include \`Fixes #${taskNumber}\` in PR body`,
              '4. Never use destructive commands'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: taskNumber,
              body: commentBody
            });
            console.log(`Added instructions comment to issue #${taskNumber}`);

  # Job 2: Merge ready Copilot PRs (runs after orchestrate to avoid race conditions)
  merge-copilot-prs:
    runs-on: ubuntu-latest
    needs: [orchestrate]
    if: always()
    
    steps:
      - name: Find and Merge Copilot PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_AW_AGENT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              sort: 'created',
              direction: 'asc'
            });
            
            const copilotPRs = prs.filter(pr => {
              const login = pr.user.login.toLowerCase();
              return login === 'copilot' || login === 'copilot-swe-agent' || login.includes('copilot');
            });
            
            if (copilotPRs.length === 0) {
              console.log('No open Copilot PRs found');
              return;
            }
            
            // Check if Copilot is still actively working (has in_progress workflow)
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              status: 'in_progress',
              per_page: 10
            });
            
            const copilotActiveRun = workflowRuns.workflow_runs.find(run => {
              const name = (run.name || '').toLowerCase();
              const actor = (run.actor?.login || '').toLowerCase();
              return name.includes('copilot') || actor.includes('copilot');
            });
            
            if (copilotActiveRun) {
              console.log(`Copilot is still working (run ${copilotActiveRun.id}). Skipping merge.`);
              return;
            }
            
            for (const pr of copilotPRs) {
              console.log(`Processing PR #${pr.number}: ${pr.title}`);
              
              // Skip WIP PRs - Copilot is still working on them
              if (pr.title.includes('[WIP]') || pr.title.toLowerCase().startsWith('wip')) {
                console.log('  Skipping: PR is marked as Work In Progress');
                continue;
              }
              
              // Check if there's an active Copilot session on this PR's branch
              const prBranchActiveRun = workflowRuns.workflow_runs.find(run => 
                run.head_branch === pr.head.ref
              );
              
              if (prBranchActiveRun) {
                console.log(`  Skipping: Active Copilot session on branch ${pr.head.ref}`);
                continue;
              }
              
              // Get full PR details
              const { data: prDetails } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number
              });
              
              // If PR is draft but no [WIP] and no active session, mark it ready
              if (prDetails.draft) {
                console.log('  PR is draft but Copilot seems done. Marking ready for review...');
                try {
                  await github.graphql(`
                    mutation($prId: ID!) {
                      markPullRequestReadyForReview(input: { pullRequestId: $prId }) {
                        pullRequest { id }
                      }
                    }
                  `, { prId: pr.node_id });
                  console.log(`  ✅ Marked PR #${pr.number} as ready for review`);
                } catch (error) {
                  console.log(`  ⚠️ Could not mark ready: ${error.message}`);
                  continue;
                }
              }
              
              if (prDetails.mergeable_state === 'dirty' || prDetails.mergeable_state === 'blocked') {
                console.log(`  Skipping: PR is ${prDetails.mergeable_state}`);
                continue;
              }
              
              try {
                await github.rest.pulls.createReview({
                  owner,
                  repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: 'Auto-approved by Mayor West Orchestrator'
                });
                console.log(`  ✅ Approved PR #${pr.number}`);
              } catch (error) {
                console.log(`  Could not approve: ${error.message}`);
              }
              
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: 'squash'
                });
                console.log(`  ✅ Merged PR #${pr.number}`);
                
                // STOP after merging one PR - next run will pick up the next one
                console.log('Stopping after merging one PR. Next task will be assigned on next run.');
                return;
              } catch (error) {
                console.log(`  ❌ Could not merge: ${error.message}`);
                // Continue to try next PR if this one failed
              }
            }
